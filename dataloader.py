import os
import torch
import random
import copy
import csv
from PIL import Image

from torch.utils.data import Dataset
import torchvision.transforms as transforms
from torch.utils.data.dataset import Dataset
import numpy as np
import pydicom as dicom
import cv2
from skimage import transform, io, img_as_float, exposure
from albumentations import (
    Compose,
    HorizontalFlip,
    CLAHE,
    HueSaturationValue,
    RandomBrightness,
    RandomBrightnessContrast,
    RandomGamma,
    OneOf,
    ToFloat,
    ShiftScaleRotate,
    GridDistortion,
    ElasticTransform,
    JpegCompression,
    HueSaturationValue,
    RGBShift,
    RandomBrightness,
    RandomContrast,
    Blur,
    MotionBlur,
    MedianBlur,
    GaussNoise,
    CenterCrop,
    IAAAdditiveGaussianNoise,
    GaussNoise,
    OpticalDistortion,
    RandomSizedCrop,
)


def build_transform_classification(
    normalize, crop_size=224, resize=256, mode="train", test_augment=True
):
    transformations_list = []

    if normalize.lower() == "imagenet":
        normalize = transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    elif normalize.lower() == "chestx-ray":
        normalize = transforms.Normalize(
            [0.5056, 0.5056, 0.5056], [0.252, 0.252, 0.252]
        )
    elif normalize.lower() == "none":
        normalize = None
    else:
        print("mean and std for [{}] dataset do not exist!".format(normalize))
        exit(-1)
    if mode == "train":
        transformations_list.append(transforms.RandomResizedCrop(crop_size))
        transformations_list.append(transforms.RandomHorizontalFlip())
        transformations_list.append(transforms.RandomRotation(7))
        transformations_list.append(transforms.ToTensor())
        if normalize is not None:
            transformations_list.append(normalize)
    elif mode == "valid":
        transformations_list.append(transforms.Resize((resize, resize)))
        transformations_list.append(transforms.CenterCrop(crop_size))
        transformations_list.append(transforms.ToTensor())
        if normalize is not None:
            transformations_list.append(normalize)
    elif mode == "test":
        if test_augment:
            transformations_list.append(transforms.Resize((resize, resize)))
            transformations_list.append(transforms.TenCrop(crop_size))
            transformations_list.append(
                transforms.Lambda(
                    lambda crops: torch.stack(
                        [transforms.ToTensor()(crop) for crop in crops]
                    )
                )
            )
            if normalize is not None:
                transformations_list.append(
                    transforms.Lambda(
                        lambda crops: torch.stack([normalize(crop) for crop in crops])
                    )
                )
        else:
            transformations_list.append(transforms.Resize((resize, resize)))
            transformations_list.append(transforms.CenterCrop(crop_size))
            transformations_list.append(transforms.ToTensor())
            if normalize is not None:
                transformations_list.append(normalize)
    transformSequence = transforms.Compose(transformations_list)

    return transformSequence


def build_transform_segmentation():
    AUGMENTATIONS_TRAIN = Compose(
        [
            # HorizontalFlip(p=0.5),
            OneOf(
                [
                    RandomBrightnessContrast(),
                    RandomGamma(),
                ],
                p=0.3,
            ),
            OneOf(
                [
                    ElasticTransform(
                        alpha=120, sigma=120 * 0.05, alpha_affine=120 * 0.03
                    ),
                    GridDistortion(),
                    OpticalDistortion(distort_limit=2, shift_limit=0.5),
                ],
                p=0.3,
            ),
            RandomSizedCrop(min_max_height=(156, 224), height=224, width=224, p=0.25),
            ToFloat(max_value=1),
        ],
        p=1,
    )

    return AUGMENTATIONS_TRAIN


class ChestXray14Dataset(Dataset):

    def __init__(
        self, images_path, file_path, augment, num_class=14, annotation_percent=100
    ):

        self.img_list = []
        self.img_label = []
        self.augment = augment

        with open(file_path, "r") as fileDescriptor:
            line = True

            while line:
                line = fileDescriptor.readline()

                if line:
                    lineItems = line.split()

                    imagePath = os.path.join(images_path, lineItems[0])
                    imageLabel = lineItems[1 : num_class + 1]
                    imageLabel = [int(i) for i in imageLabel]

                    self.img_list.append(imagePath)
                    self.img_label.append(imageLabel)

        indexes = np.arange(len(self.img_list))
        if annotation_percent < 100:
            random.Random(99).shuffle(indexes)
            num_data = int(indexes.shape[0] * annotation_percent / 100.0)
            indexes = indexes[:num_data]

            _img_list, _img_label = copy.deepcopy(self.img_list), copy.deepcopy(
                self.img_label
            )
            self.img_list = []
            self.img_label = []

            for i in indexes:
                self.img_list.append(_img_list[i])
                self.img_label.append(_img_label[i])

    def __getitem__(self, index):

        imagePath = self.img_list[index]

        imageData = Image.open(imagePath).convert("RGB")
        imageLabel = torch.FloatTensor(self.img_label[index])

        if self.augment != None:
            imageData = self.augment(imageData)

        return imageData, imageLabel

    def __len__(self):

        return len(self.img_list)


# ---------------------------------------------Downstream CheXpert------------------------------------------
class CheXpertDataset(Dataset):

    def __init__(
        self,
        images_path,
        file_path,
        augment,
        num_class=14,
        uncertain_label="LSR-Ones",
        unknown_label=0,
        annotation_percent=100,
    ):

        self.img_list = []
        self.img_label = []
        self.augment = augment
        assert uncertain_label in ["Ones", "Zeros", "LSR-Ones", "LSR-Zeros"]
        self.uncertain_label = uncertain_label

        with open(file_path, "r") as fileDescriptor:
            csvReader = csv.reader(fileDescriptor)
            next(csvReader, None)
            for line in csvReader:
                imagePath = os.path.join(images_path, line[0])
                label = line[5:]
                for i in range(num_class):
                    if label[i]:
                        a = float(label[i])
                        if a == 1:
                            label[i] = 1
                        elif a == 0:
                            label[i] = 0
                        elif a == -1:  # uncertain label
                            label[i] = -1
                    else:
                        label[i] = unknown_label  # unknown label

                self.img_list.append(imagePath)
                imageLabel = [int(i) for i in label]
                self.img_label.append(imageLabel)

        indexes = np.arange(len(self.img_list))
        if annotation_percent < 100:
            random.Random(99).shuffle(indexes)
            num_data = int(indexes.shape[0] * annotation_percent / 100.0)
            indexes = indexes[:num_data]

            _img_list, _img_label = copy.deepcopy(self.img_list), copy.deepcopy(
                self.img_label
            )
            self.img_list = []
            self.img_label = []

            for i in indexes:
                self.img_list.append(_img_list[i])
                self.img_label.append(_img_label[i])

    def __getitem__(self, index):

        imagePath = self.img_list[index]

        imageData = Image.open(imagePath).convert("RGB")

        label = []
        for l in self.img_label[index]:
            if l == -1:
                if self.uncertain_label == "Ones":
                    label.append(1)
                elif self.uncertain_label == "Zeros":
                    label.append(0)
                elif self.uncertain_label == "LSR-Ones":
                    label.append(random.uniform(0.55, 0.85))
                elif self.uncertain_label == "LSR-Zeros":
                    label.append(random.uniform(0, 0.3))
            else:
                label.append(l)
        imageLabel = torch.FloatTensor(label)

        if self.augment != None:
            imageData = self.augment(imageData)

        return imageData, imageLabel

    def __len__(self):

        return len(self.img_list)


# ---------------------------------------------Downstream Shenzhen------------------------------------------
class ShenzhenCXR(Dataset):

    def __init__(
        self, images_path, file_path, augment, num_class=1, annotation_percent=100
    ):

        self.img_list = []
        self.img_label = []
        self.augment = augment

        with open(file_path, "r") as fileDescriptor:
            line = True

            while line:
                line = fileDescriptor.readline()
                if line:
                    lineItems = line.split(",")

                    imagePath = os.path.join(images_path, lineItems[0])
                    imageLabel = lineItems[1 : num_class + 1]
                    imageLabel = [int(i) for i in imageLabel]

                    self.img_list.append(imagePath)
                    self.img_label.append(imageLabel)

        indexes = np.arange(len(self.img_list))
        if annotation_percent < 100:
            random.Random(99).shuffle(indexes)
            num_data = int(indexes.shape[0] * annotation_percent / 100.0)
            indexes = indexes[:num_data]

            _img_list, _img_label = copy.deepcopy(self.img_list), copy.deepcopy(
                self.img_label
            )
            self.img_list = []
            self.img_label = []

            for i in indexes:
                self.img_list.append(_img_list[i])
                self.img_label.append(_img_label[i])

    def __getitem__(self, index):

        imagePath = self.img_list[index]

        imageData = Image.open(imagePath).convert("RGB")

        imageLabel = torch.FloatTensor(self.img_label[index])

        if self.augment != None:
            imageData = self.augment(imageData)

        return imageData, imageLabel

    def __len__(self):

        return len(self.img_list)


# ---------------------------------------------Downstream VinDrCXR------------------------------------------
class VinDrCXR(Dataset):
    def __init__(
        self, images_path, file_path, augment, num_class=6, annotation_percent=100
    ):
        self.img_list = []
        self.img_label = []
        self.augment = augment

        with open(file_path, "r") as fr:
            line = fr.readline().strip()
            while line:
                lineItems = line.split()
                imagePath = os.path.join(images_path, lineItems[0] + ".jpeg")
                imageLabel = lineItems[1:]
                imageLabel = [int(i) for i in imageLabel]
                self.img_list.append(imagePath)
                self.img_label.append(imageLabel)
                line = fr.readline()

        if annotation_percent < 100:
            indexes = np.arange(len(self.img_list))
            random.Random(99).shuffle(indexes)
            num_data = int(indexes.shape[0] * annotation_percent / 100.0)
            indexes = indexes[:num_data]

            _img_list, _img_label = copy.deepcopy(self.img_list), copy.deepcopy(
                self.img_label
            )
            self.img_list = []
            self.img_label = []

            for i in indexes:
                self.img_list.append(_img_list[i])
                self.img_label.append(_img_label[i])

    def __getitem__(self, index):

        imagePath = self.img_list[index]
        imageLabel = torch.FloatTensor(self.img_label[index])
        imageData = Image.open(imagePath).convert("RGB")
        if self.augment != None:
            imageData = self.augment(imageData)
        return imageData, imageLabel

    def __len__(self):

        return len(self.img_list)


# ---------------------------------------------Downstream VinDrPCXR------------------------------------------
class VinDrPCXR(Dataset):
    def __init__(
        self, images_path, file_path, augment, num_class=15, annotation_percent=100
    ):
        self.img_list = []
        self.img_label = []
        self.augment = augment

        with open(file_path, "r") as fr:
            line = fr.readline().strip()
            while line:
                lineItems = line.split(",")
                imagePath = os.path.join(images_path, lineItems[1] + ".jpeg")
                imageLabel = lineItems[2:]
                imageLabel = [int(float(i)) for i in imageLabel]
                self.img_list.append(imagePath)
                self.img_label.append(imageLabel)
                line = fr.readline()

        if annotation_percent < 100:
            indexes = np.arange(len(self.img_list))
            random.Random(99).shuffle(indexes)
            num_data = int(indexes.shape[0] * annotation_percent / 100.0)
            indexes = indexes[:num_data]

            _img_list, _img_label = copy.deepcopy(self.img_list), copy.deepcopy(
                self.img_label
            )
            self.img_list = []
            self.img_label = []

            for i in indexes:
                self.img_list.append(_img_list[i])
                self.img_label.append(_img_label[i])

    def __getitem__(self, index):

        imagePath = self.img_list[index]
        imageLabel = torch.FloatTensor(self.img_label[index])
        imageData = Image.open(imagePath).convert("RGB")
        if self.augment != None:
            imageData = self.augment(imageData)
        return imageData, imageLabel

    def __len__(self):

        return len(self.img_list)


# ---------------------------------------------Downstream RSNA Pneumonia------------------------------------------
class RSNAPneumonia(Dataset):

    def __init__(self, images_path, file_path, augment, annotation_percent=100):

        self.img_list = []
        self.img_label = []
        self.augment = augment

        with open(file_path, "r") as fileDescriptor:
            line = True

            while line:
                line = fileDescriptor.readline()
                if line:
                    lineItems = line.strip().split(" ")
                    imagePath = os.path.join(images_path, lineItems[0])

                    self.img_list.append(imagePath)
                    self.img_label.append(int(lineItems[-1]))

        indexes = np.arange(len(self.img_list))
        if annotation_percent < 100:
            random.Random(99).shuffle(indexes)
            num_data = int(indexes.shape[0] * annotation_percent / 100.0)
            indexes = indexes[:num_data]

            _img_list, _img_label = copy.deepcopy(self.img_list), copy.deepcopy(
                self.img_label
            )
            self.img_list = []
            self.img_label = []

            for i in indexes:
                self.img_list.append(_img_list[i])
                self.img_label.append(_img_label[i])

    def __getitem__(self, index):

        imagePath = self.img_list[index]
        imageData = Image.open(imagePath).convert("RGB")
        imageLabel = np.zeros(3)
        imageLabel[self.img_label[index]] = 1
        if self.augment != None:
            imageData = self.augment(imageData)

        return imageData, imageLabel

    def __len__(self):

        return len(self.img_list)
